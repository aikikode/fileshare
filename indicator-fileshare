#!/usr/bin/env python
#
# Copyright 2012
#
# Authors: Denis Kovalev <aikikode@gmail.com>
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of either or both of the following licenses:
#
# 1) the GNU Lesser General Public License version 3, as published by the
# Free Software Foundation; and/or
# 2) the GNU Lesser General Public License version 2.1, as published by
# the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the applicable version of the GNU Lesser General Public
# License for more details.
#
# You should have received a copy of both the GNU Lesser General Public
# License version 3 and version 2.1 along with this program.  If not, see
# <http://www.gnu.org/licenses>
#

import sys, os, shutil, tempfile
import ConfigParser
import gtk
import appindicator
import threading
import webbrowser
import logging, logging.handlers
import commands
# for OAuth
from oauth_hook import OAuthHook
import requests
from urlparse import parse_qs
# for uploading
import pycurl
import base64
# for parsing server response
import xml.dom.minidom
# for delayed actions
import gobject

VERSION = "0.1"
FILE_GRABBER_SIZE=50
# Anonymous access
ANONYMOUS_API_KEY="fba6adcf28f8439062ea52f22600e672"
# Account based access
CONSUMER_KEY="61aadc0beb93b6181adb6f3833e86fe9050993c85"
CONSUMER_SECRET="fbf2b4ced06d3d399d39dece82d5f488"

CONFIG_FILE="~/.fileshare/settings.cfg"

class SingleInstance(object):
    """ Class to ensure, that single instance of the applet is run for each user """

    # Initialize, specifying a path to store pids
    def __init__(self, pidPath):
        self.pidPath=pidPath
        # See if pidFile exists
        if os.path.exists(pidPath):
            log.debug("SingleInstance: pid file %s exists" % pidPath)
            # Make sure it is not a "stale" pidFile
            pid=open(pidPath, 'r').read().strip()
            # Check list of running pids, if not running it is stale so overwrite
            pidRunning = commands.getoutput('ls -1 /proc | grep ^%s$' % pid)
            log.debug("SingleInstance: pid running %s" % pidRunning)
            self.lasterror = True if pidRunning else False
        else:
            self.lasterror = False

        if not self.lasterror:
            log.debug("SingleInstance: writing new pid %s" % str(os.getpid()))
            # Create a temp file, copy it to pidPath and remove temporary file
            (fp, temp_path)=tempfile.mkstemp()
            try:
                os.fdopen(fp, "w+b").write(str(os.getpid()))
                shutil.copy(temp_path, pidPath)
                os.unlink(temp_path)
            except Exception as e:
                log.error("SingleInstance: exception while renaming '%s' to '%s':\n %s" % (temp_path, pidPath, str(e)))
    #def __init__(self, pidPath)

    def is_already_running(self):
        return self.lasterror

    def __del__(self):
        if not self.lasterror:
            log.debug("SingleInstance: deleting %s" % self.pidPath)
            os.unlink(self.pidPath)
    #def __del__(self)
#class SingleInstance(object)

class IndicatorFileshare(threading.Thread):
    def __init__(self):
        log.debug("Indicator: creating")
        threading.Thread.__init__(self)
        self.read_settings()
        self.ind = appindicator.Indicator("fileshare-services-client",
            "indicator-fileshare",
            appindicator.CATEGORY_APPLICATION_STATUS)
        self.ind.set_status (appindicator.STATUS_ACTIVE)
        self.ind.set_icon("/usr/local/share/indicator-fileshare/media/app_icon.png")
        self.file_grabber = FileGrabber()
        self.create_menu()

    def read_settings(self):
        config = ConfigParser.RawConfigParser()
        try:
            config.read(CONFIG_FILE)
            self.final_token = config.get("Auth", "final_token")
            self.final_token_secret = config.get("Auth", "final_token_secret")
        except:
            self.final_token = None
            self.final_token_secret = None
    #def read_settings(self)

    def create_menu(self):
        self.menu = gtk.Menu()
        # Create menu items
        ## Open imgur site
        buf = "Open Imgur"
        menu_item_open_site_url = gtk.MenuItem(buf)
        self.menu.append(menu_item_open_site_url)
        menu_item_open_site_url.connect("activate", self.open_site, buf)
        menu_item_open_site_url.show()

        ## Widget for grabbing files
        grab_files = gtk.MenuItem("Show/hide File Grabber")
        grab_files.connect("activate", self.toggle_file_grabber)
        grab_files.show()
        self.menu.append(grab_files)

        ## Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        ## Auth or Logout menu
        if self.final_token is None:
            login = gtk.MenuItem("Login...")
            login.connect("activate", self.login)
            login.show()
            self.menu.append(login)
        else:
            logout = gtk.MenuItem("Logout...")
            logout.connect("activate", self.logout)
            logout.show()
            self.menu.append(logout)

        ##About
        about_show = gtk.MenuItem("About...")
        about_show.connect("activate", self.about)
        about_show.show()
        self.menu.append(about_show)

        ##Quit
        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)

        # set menu
        self.ind.set_menu(self.menu)
    #def create_menu(self)

    def open_site(self, widget, buf):
        webbrowser.open('https://imgur.com/')

    def toggle_file_grabber(self, widget):
        self.file_grabber.toggle_window()

    def login(self, widget):
        # Stage 1
        imgur_oauth_hook = OAuthHook(consumer_key=CONSUMER_KEY, consumer_secret=CONSUMER_SECRET)
        response = requests.post('http://api.imgur.com/oauth/request_token', hooks={'pre_request': imgur_oauth_hook})
        qs = parse_qs(response.text)
        oauth_token = qs['oauth_token'][0]
        oauth_secret = qs['oauth_token_secret'][0]
        # Stage 2

#        print "Go to http://api.imgur.com/oauth/authorize?oauth_token=%s allow the app and copy your PIN" % oauth_token
#        oauth_verifier = raw_input('Please enter your PIN:')
        oauth_verifier = self.get_pin(oauth_token)
        # Stage 3
        new_imgur_oauth_hook = OAuthHook(oauth_token, oauth_secret, CONSUMER_KEY, CONSUMER_SECRET)
        response = requests.post('http://api.imgur.com/oauth/access_token', {'oauth_verifier': oauth_verifier}, hooks={'pre_request': new_imgur_oauth_hook})
        response = parse_qs(response.content)
        self.final_token = response['oauth_token'][0]
        self.final_token_secret = response['oauth_token_secret'][0]

    def responseToDialog(self, entry, dialog, response):
        dialog.response(response)

    def get_pin(self, oauth_token):
        #base this on a message dialog
        dialog = gtk.MessageDialog(
            None,
            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
            gtk.MESSAGE_QUESTION,
            gtk.BUTTONS_OK,
            None)
        dialog.set_markup("Go to \"http://api.imgur.com/oauth/authorize?oauth_token=%s\", allow the app and copy your PIN" % oauth_token)
        webbrowser.open("http://api.imgur.com/oauth/authorize?oauth_token=%s" % oauth_token)
        #create the text input field
        entry = gtk.Entry()
        #allow the user to press enter to do ok
        entry.connect("activate", self.responseToDialog, dialog, gtk.RESPONSE_OK)
        #create a horizontal box to pack the entry and a label
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Name:"), False, 5, 5)
        hbox.pack_end(entry)
        #some secondary text
        dialog.format_secondary_markup("Please, enter your PIN:")
        #add it and show it
        dialog.vbox.pack_end(hbox, True, True, 0)
        dialog.show_all()
        #go go go
        dialog.run()
        text = entry.get_text()
        dialog.destroy()
        return text

    def logout(self, widget):
        pass

    def about(self, widget):
        log.debug("Indicator: open About dialog")
        self.about_dialog = gtk.AboutDialog()
        self.about_dialog.set_name("Fileshare Indicator")
        self.about_dialog.set_version(VERSION)

        ifile = open("/usr/share/doc/indicator-fileshare/AUTHORS", "r")
        self.about_dialog.set_copyright(ifile.read().replace('\x0c', ''))
        ifile.close()

        self.about_dialog.set_website("https://github.com/aikikode/fileshare")
        logo_path = "/usr/local/share/indicator-fileshare/media/app_icon.png"
        self.about_dialog.set_logo(gtk.gdk.pixbuf_new_from_file(logo_path))
        self.about_dialog.connect("response", self.about_close)
        self.about_dialog.show()
    #def about(self, widget)

    def about_close(self, widget, event=None):
        log.debug("Indicator: closing About dialog")
        self.about_dialog.destroy()

    # Quit the applet
    def quit(self, widget, data=None):
        log.debug("Indicator: Quitting")
        gtk.main_quit()

class FileGrabber():
    """ Applet for drag'n'drop files to. The file is automatically uploaded to
        the hosting and the result URL is copied into the clipboard """
    def __init__(self):
        self.cb = gtk.Clipboard()
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_decorated(False)
        self.window.set_opacity(0.5)
        self.window.set_size_request(FILE_GRABBER_SIZE, FILE_GRABBER_SIZE)
        self.window.set_resizable(False)
        self.window.drag_dest_set(0, [], 0)

        self.window.set_gravity(gtk.gdk.GRAVITY_NORTH_EAST)
        width, height = self.window.get_size()
        self.window.move(gtk.gdk.screen_width() - width - 20, height)

        # Add main widget for grabbing files
        self.image = gtk.Image()
        pixbuf = gtk.gdk.pixbuf_new_from_file("/usr/local/share/indicator-fileshare/media/imgur.png")
        scaled_buf = pixbuf.scale_simple(FILE_GRABBER_SIZE, FILE_GRABBER_SIZE, gtk.gdk.INTERP_BILINEAR)
        self.image.set_from_pixbuf(scaled_buf)
        self.image.show()
        self.window.add(self.image)
        self.window.connect('drag_motion', self.window_drag_motion)
        self.window.connect('drag_drop', self.window_drag_drop)
        self.window.connect('drag_data_received', self.window_drag_data_received)
        self.isShown = False

    def toggle_window(self):
        if self.isShown:
            self.window.hide()
            self.isShown = False
        else:
            self.window.show()
            self.window.set_keep_above(True)    # This may not work: it depends on the window manager
            self.isShown = True

    def window_drag_motion(self, wid, context, x, y, time):
        context.drag_status(gtk.gdk.ACTION_COPY, time)
        return True      # True means "I accept this data"

    def window_drag_drop(self, wid, context, x, y, time):
        wid.drag_get_data(context, context.targets[-1], time)
        return True

    def window_drag_data_received(self, wid, context, x, y, data, info, time):
        file_to_upload = data.get_text().splitlines()[0].replace("file://", "")
        context.finish(True, False, time)
        self.upload(file_to_upload)
        self.show_result()

    def upload(self, image):
        log.debug("Uploading file: " + image)
        self.response = ''
        self.base64String = self.img2base64(image)
        self.curl = curl = pycurl.Curl()
        curl.setopt(pycurl.URL, 'http://api.imgur.com/2/upload.xml')
        curl.setopt(pycurl.USERAGENT, 'Mozilla/5.0 Nanoshot')
        curl.setopt(pycurl.POST, 1)
        curl.setopt(pycurl.HTTPPOST, [ ('key', ANONYMOUS_API_KEY), ('image', self.base64String) ])
        curl.setopt(pycurl.WRITEFUNCTION, self.write)
        self.curl.perform()
        log.debug("Response: " + self.response)
        self.dom = xml.dom.minidom.parseString(self.response)
        return True

    def img2base64(self, image):
        with open(image, "rb") as image_file:
            encoded_string = base64.b64encode(image_file.read())
        return encoded_string

    def write(self, string):
        self.response += string

    def show_result(self):
        links = []
        for tag in ('original', 'delete_page'):
            link = self.dom.getElementsByTagName(tag)
            if link:
                links.append((tag, link[0].firstChild.nodeValue))
        print links
        url = links[0][1]
        self.cb.set_text(url)
        self.cb.store()
        # create a window with result URL
        result_window = gtk.Window()
        result_window.set_decorated(False)
        result_window.set_opacity(0.9)
        result_window.set_resizable(False)
        result_window.set_gravity(gtk.gdk.GRAVITY_NORTH_EAST)
        width, height = result_window.get_size()
        result_window.move(gtk.gdk.screen_width() - width - 20, height)
        l = gtk.Label()
        l.set_text(url + " copied")
        l.show()
        result_window.add(l)
        result_window.show()
        # close the window with URL in 5 seconds
        gobject.timeout_add(5000, result_window.hide)
    #def show_result(self)
#class FileGrabber()


def main():
    gtk.main()
    return 0

if __name__ == "__main__":
    #Enable and configure logs
    global log
    cachedir = os.environ.get('XDG_CACHE_HOME','').strip()
    if not cachedir:
        cachedir = os.path.expanduser("~/.cache")
    log_filename = os.path.join(cachedir, "indicator-fileshare.log")
    log = logging.getLogger('IndicatorFileshare')
    log.propagate = False
    log.setLevel(logging.DEBUG)
    log_handler = logging.handlers.RotatingFileHandler(log_filename, maxBytes=1024*1024, backupCount=5)
    log_formatter = logging.Formatter("[%(threadName)s] %(asctime)s - %(levelname)s - %(message)s")
    log_handler.setFormatter(log_formatter)
    log.addHandler(log_handler)

    log.info("------------------------------")
    log.info("Started Fileshare Indicator")
    log.info("Fileshare Indicator version %s" % VERSION)

    # Single instance stuff for fileshare indicator
    myapp = SingleInstance("/tmp/indicator-fileshare-%d.pid" % os.getuid())
    # check is another instance of same program running
    if myapp.is_already_running():
        log.info("Another instance of this program is already running")
        sys.exit("Another instance of this program is already running")
    # not running, safe to continue...
    gtk.gdk.threads_init()
    gtk.gdk.threads_enter()

    di = IndicatorFileshare()
    main()
    gtk.gdk.threads_leave()