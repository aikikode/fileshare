#!/usr/bin/env python
#
# Copyright 2012
#
# Authors: Denis Kovalev <aikikode@gmail.com>
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of either or both of the following licenses:
#
# 1) the GNU Lesser General Public License version 3, as published by the
# Free Software Foundation; and/or
# 2) the GNU Lesser General Public License version 2.1, as published by
# the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the applicable version of the GNU Lesser General Public
# License for more details.
#
# You should have received a copy of both the GNU Lesser General Public
# License version 3 and version 2.1 along with this program.  If not, see
# <http://www.gnu.org/licenses>
#

import sys, os, shutil, tempfile
import gtk
import appindicator
import threading
import webbrowser
import logging, logging.handlers
import commands
# for uploading
import pycurl
import base64
# for parsing server response
import xml.dom.minidom
# for delayed actions
import gobject

VERSION = "0.1"
ANONYMOUS_API_KEY="fba6adcf28f8439062ea52f22600e672"
FILE_GRABBER_SIZE=50

class SingleInstance(object):
    """ Class to ensure, that single instance of the applet is run for each user """

    # Initialize, specifying a path to store pids
    def __init__(self, pidPath):
        self.pidPath=pidPath
        # See if pidFile exists
        if os.path.exists(pidPath):
            log.debug("SingleInstance: pid file %s exists" % pidPath)
            # Make sure it is not a "stale" pidFile
            pid=open(pidPath, 'r').read().strip()
            # Check list of running pids, if not running it is stale so overwrite
            pidRunning = commands.getoutput('ls -1 /proc | grep ^%s$' % pid)
            log.debug("SingleInstance: pid running %s" % pidRunning)
            self.lasterror = True if pidRunning else False
        else:
            self.lasterror = False

        if not self.lasterror:
            log.debug("SingleInstance: writing new pid %s" % str(os.getpid()))
            # Create a temp file, copy it to pidPath and remove temporary file
            (fp, temp_path)=tempfile.mkstemp()
            try:
                os.fdopen(fp, "w+b").write(str(os.getpid()))
                shutil.copy(temp_path, pidPath)
                os.unlink(temp_path)
            except Exception as e:
                log.error("SingleInstance: exception while renaming '%s' to '%s':\n %s" % (temp_path, pidPath, str(e)))
    #def __init__(self, pidPath)

    def is_already_running(self):
        return self.lasterror

    def __del__(self):
        if not self.lasterror:
            log.debug("SingleInstance: deleting %s" % self.pidPath)
            os.unlink(self.pidPath)
    #def __del__(self)
#class SingleInstance(object)

class IndicatorFileshare(threading.Thread):
    def __init__(self):
        log.debug("Indicator: creating")
        threading.Thread.__init__(self)
        self.ind = appindicator.Indicator("fileshare-services-client",
            "indicator-fileshare",
            appindicator.CATEGORY_APPLICATION_STATUS)
        self.ind.set_status (appindicator.STATUS_ACTIVE)
        self.ind.set_icon("/usr/local/share/indicator-fileshare/media/app_icon.png")
        self.file_grabber = FileGrabber()
        self.create_menu()

    def create_menu(self):
        self.menu = gtk.Menu()
        # Create menu items
        ## Open imgur site
        buf = "Open Imgur"
        menu_item_open_site_url = gtk.MenuItem(buf)
        self.menu.append(menu_item_open_site_url)
        menu_item_open_site_url.connect("activate", self.open_site, buf)
        menu_item_open_site_url.show()

        ## Widget for grabbing files
        grab_files = gtk.MenuItem("Show/hide File Grabber")
        grab_files.connect("activate", self.toggle_file_grabber)
        grab_files.show()
        self.menu.append(grab_files)

        ## Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        ##About
        about_show = gtk.MenuItem("About...")
        about_show.connect("activate", self.about)
        about_show.show()
        self.menu.append(about_show)

        ##Quit
        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)

        # set menu
        self.ind.set_menu(self.menu)
    #def create_menu(self)

    def open_site(self, widget, buf):
        webbrowser.open('https://imgur.com/')

    def toggle_file_grabber(self, widget):
        self.file_grabber.toggle_window()

    def about(self, widget):
        log.debug("Indicator: open About dialog")
        self.about_dialog = gtk.AboutDialog()
        self.about_dialog.set_name("Fileshare Indicator")
        self.about_dialog.set_version(VERSION)

        ifile = open("/usr/share/doc/indicator-fileshare/AUTHORS", "r")
        self.about_dialog.set_copyright(ifile.read().replace('\x0c', ''))
        ifile.close()

        self.about_dialog.set_website("https://github.com/aikikode/fileshare")
        logo_path = "/usr/local/share/indicator-fileshare/media/app_icon.png"
        self.about_dialog.set_logo(gtk.gdk.pixbuf_new_from_file(logo_path))
        self.about_dialog.connect("response", self.about_close)
        self.about_dialog.show()
    #def about(self, widget)

    def about_close(self, widget, event=None):
        log.debug("Indicator: closing About dialog")
        self.about_dialog.destroy()

    # Quit the applet
    def quit(self, widget, data=None):
        log.debug("Indicator: Quitting")
        gtk.main_quit()

class FileGrabber():
    """ Applet for drag'n'drop files to. The file is automatically uploaded to
        the hosting and the result URL is copied into the clipboard """
    def __init__(self):
        self.cb = gtk.Clipboard()
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_decorated(False)
        self.window.set_opacity(0.5)
        self.window.set_size_request(FILE_GRABBER_SIZE, FILE_GRABBER_SIZE)
        self.window.set_resizable(False)
        self.window.drag_dest_set(0, [], 0)

        self.window.set_gravity(gtk.gdk.GRAVITY_NORTH_EAST)
        width, height = self.window.get_size()
        self.window.move(gtk.gdk.screen_width() - width - 20, height)

        # Add main widget for grabbing files
        self.image = gtk.Image()
        pixbuf = gtk.gdk.pixbuf_new_from_file("/usr/local/share/indicator-fileshare/media/imgur.png")
        scaled_buf = pixbuf.scale_simple(FILE_GRABBER_SIZE, FILE_GRABBER_SIZE, gtk.gdk.INTERP_BILINEAR)
        self.image.set_from_pixbuf(scaled_buf)
        self.image.show()
        self.window.add(self.image)
        self.window.connect('drag_motion', self.window_drag_motion)
        self.window.connect('drag_drop', self.window_drag_drop)
        self.window.connect('drag_data_received', self.window_drag_data_received)
        self.isShown = False

    def toggle_window(self):
        if self.isShown:
            self.window.hide()
            self.isShown = False
        else:
            self.window.show()
            self.window.set_keep_above(True)    # This may not work: it depends on the window manager
            self.isShown = True

    def window_drag_motion(self, wid, context, x, y, time):
        context.drag_status(gtk.gdk.ACTION_COPY, time)
        return True      # True means "I accept this data"

    def window_drag_drop(self, wid, context, x, y, time):
        wid.drag_get_data(context, context.targets[-1], time)
        return True

    def window_drag_data_received(self, wid, context, x, y, data, info, time):
        file_to_upload = data.get_text().splitlines()[0].replace("file://", "")
        context.finish(True, False, time)
        self.upload(file_to_upload)
        self.show_result()

    def upload(self, image):
        log.debug("Uploading file: " + image)
        self.response = ''
        self.base64String = self.img2base64(image)
        self.curl = curl = pycurl.Curl()
        curl.setopt(pycurl.URL, 'http://api.imgur.com/2/upload.xml')
        curl.setopt(pycurl.USERAGENT, 'Mozilla/5.0 Nanoshot')
        curl.setopt(pycurl.POST, 1)
        curl.setopt(pycurl.HTTPPOST, [ ('key', ANONYMOUS_API_KEY), ('image', self.base64String) ])
        curl.setopt(pycurl.WRITEFUNCTION, self.write)
        self.curl.perform()
        log.debug("Response: " + self.response)
        self.dom = xml.dom.minidom.parseString(self.response)
        return True

    def img2base64(self, image):
        with open(image, "rb") as image_file:
            encoded_string = base64.b64encode(image_file.read())
        return encoded_string

    def write(self, string):
        self.response += string

    def show_result(self):
        links = []
        for tag in ('original', 'delete_page'):
            link = self.dom.getElementsByTagName(tag)
            if link:
                links.append((tag, link[0].firstChild.nodeValue))
        print links
        url = links[0][1]
        self.cb.set_text(url)
        self.cb.store()
        # create a window with result URL
        result_window = gtk.Window()
        result_window.set_decorated(False)
        result_window.set_opacity(0.9)
        result_window.set_resizable(False)
        result_window.set_gravity(gtk.gdk.GRAVITY_NORTH_EAST)
        width, height = result_window.get_size()
        result_window.move(gtk.gdk.screen_width() - width - 20, height)
        l = gtk.Label()
        l.set_text(url + " copied")
        l.show()
        result_window.add(l)
        result_window.show()
        # close the window with URL in 5 seconds
        gobject.timeout_add(5000, result_window.hide)
    #def show_result(self)
#class FileGrabber()


def main():
    gtk.main()
    return 0

if __name__ == "__main__":
    #Enable and configure logs
    global log
    cachedir = os.environ.get('XDG_CACHE_HOME','').strip()
    if not cachedir:
        cachedir = os.path.expanduser("~/.cache")
    log_filename = os.path.join(cachedir, "indicator-fileshare.log")
    log = logging.getLogger('IndicatorFileshare')
    log.propagate = False
    log.setLevel(logging.DEBUG)
    log_handler = logging.handlers.RotatingFileHandler(log_filename, maxBytes=1024*1024, backupCount=5)
    log_formatter = logging.Formatter("[%(threadName)s] %(asctime)s - %(levelname)s - %(message)s")
    log_handler.setFormatter(log_formatter)
    log.addHandler(log_handler)

    log.info("------------------------------")
    log.info("Started Fileshare Indicator")
    log.info("Fileshare Indicator version %s" % VERSION)

    # Single instance stuff for fileshare indicator
    myapp = SingleInstance("/tmp/indicator-fileshare-%d.pid" % os.getuid())
    # check is another instance of same program running
    if myapp.is_already_running():
        log.info("Another instance of this program is already running")
        sys.exit("Another instance of this program is already running")
    # not running, safe to continue...
    gtk.gdk.threads_init()
    gtk.gdk.threads_enter()

    di = IndicatorFileshare()
    main()
    gtk.gdk.threads_leave()