#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2012
#
# Authors: Denis Kovalev <aikikode@gmail.com>
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of either or both of the following licenses:
#
# 1) the GNU Lesser General Public License version 3, as published by the
# Free Software Foundation; and/or
# 2) the GNU Lesser General Public License version 2.1, as published by
# the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the applicable version of the GNU Lesser General Public
# License for more details.
#
# You should have received a copy of both the GNU Lesser General Public
# License version 3 and version 2.1 along with this program.  If not, see
# <http://www.gnu.org/licenses>
#

_author__ = 'aikikode'

import sys, os, stat, shutil, tempfile
import ConfigParser
import gtk
import threading
import webbrowser
import logging, logging.handlers
import commands
# for delayed actions
import gobject
import errno
import getpass

if os.name == "nt":
    IS_LINUX = False
    import subprocess
else:
    IS_LINUX = True
    import appindicator
    import pynotify

APP_DIR = '/usr/local/share/indicator-fileshare'
if APP_DIR not in sys.path:
    sys.path.append(APP_DIR)

from upload_services import Imgur, Droplr
from grabbers import FileGrabber, ScreenGrabber

DEFAULT_SERVICE_NAME = "Imgur"  # Choose Imgur because it allows anonymous uploads

gobject.threads_init()

VERSION = "0.5.1"

CONFIG_DIR = os.path.join(os.path.expanduser("~"), ".fileshare")
CONFIG_FILE = os.path.join(CONFIG_DIR, "settings.cfg")

if not os.path.isdir(CONFIG_DIR):
    os.mkdir(CONFIG_DIR)

##############################################################################
class SingleInstance(object):
    """ Class to ensure, that single instance of the applet is run for each user """

    # Initialize, specifying a path to store pids
    def __init__(self, pidPath):
        self.pidPath = pidPath
        # See if pidFile exists
        if os.path.exists(pidPath):
            log.debug("SingleInstance: pid file %s exists" % pidPath)
            # Make sure it is not a "stale" pidFile
            pid = open(pidPath, 'r').read().strip()
            # Check list of running pids, if not running it is stale so overwrite
            if IS_LINUX:
                pidRunning = commands.getoutput('ls -1 /proc | grep ^%s$' % pid)
            else:
                pidRunning = None if "No tasks are running" in subprocess.check_output('tasklist /V /FI "PID eq %s"' % pid) else pid
            log.debug("SingleInstance: pid running %s" % pidRunning)
            self.lasterror = True if pidRunning else False
        else:
            self.lasterror = False

        if not self.lasterror:
            log.debug("SingleInstance: writing new pid %s" % str(os.getpid()))
            # Create a temp file, copy it to pidPath and remove temporary file
            (fp, temp_path) = tempfile.mkstemp()
            try:
                os.fdopen(fp, "w+b").write(str(os.getpid()))
                shutil.copy(temp_path, pidPath)
                os.unlink(temp_path)
            except Exception as e:
                log.error("SingleInstance: exception while renaming '%s' to '%s':\n %s" % (temp_path, pidPath, str(e)))
    #def __init__(self, pidPath)

    def is_already_running(self):
        return self.lasterror

    def __del__(self):
        if not self.lasterror:
            log.debug("SingleInstance: deleting %s" % self.pidPath)
            os.unlink(self.pidPath)
            #def __del__(self)
#class SingleInstance(object)


##############################################################################
class IndicatorFileshare(threading.Thread):
    def __init__(self):
        log.debug("Indicator: creating")
        threading.Thread.__init__(self)
        if IS_LINUX:
            self.app_icon = "/usr/local/share/indicator-fileshare/media/app_icon.png"
        else:
            self.app_icon = "./icons/app_icon.png"
        self.read_settings()
        self.check_autostart()
        if IS_LINUX:
            self.ind = appindicator.Indicator("fileshare-services-client",
                                              "indicator-fileshare",
                                              appindicator.CATEGORY_APPLICATION_STATUS)
            self.ind.set_status(appindicator.STATUS_ACTIVE)
            self.ind.set_icon(self.app_icon)
        else:
            self.ind = gtk.StatusIcon()
            self.ind.set_from_file(self.app_icon)
            self.ind.set_title("Fileshare")
            self.ind.set_name("Fileshare")
            self.ind.set_tooltip_text("Fileshare")
            self.ind.connect("popup-menu", self.show_ind_menu)
        self.file_grabber = FileGrabber(self)
        self.create_menu()

    def show_ind_menu(self, icon, button, time):
        self.menu.show_all()
        self.menu.popup(None, None, gtk.status_icon_position_menu, button, time, self.ind)

    def read_settings(self):
        self.config = config = ConfigParser.RawConfigParser()
        try:
            config.read(CONFIG_FILE)
            self.SERVICE_NAME = config.get("SERVICE", "name")
        except Exception as e:
            log.error("Error: %s" % str(e))
            self.SERVICE_NAME = DEFAULT_SERVICE_NAME
        self.service = globals()[self.SERVICE_NAME](self, config, log)
    #def read_settings(self)

    def save_settings(self):
        self.config = config = ConfigParser.RawConfigParser()
        try:
            config = self.service.save_settings(config)
            if not config.has_section("SERVICE"):
                config.add_section("SERVICE")
            config.set("SERVICE", "name", self.SERVICE_NAME)
            with open(CONFIG_FILE, 'w+') as configfile:
                os.chmod(CONFIG_FILE, stat.S_IRUSR | stat.S_IWUSR)
                config.write(configfile)
        except Exception as e:
            log.error("Error: %s" % str(e))

    def check_autostart(self):
        autostart_dir = os.path.join(os.path.expanduser("~"), ".config/autostart/")
        autostart_file = "indicator-fileshare.desktop"
        autostart_path = os.path.join(autostart_dir, autostart_file)
        if not os.path.isfile(autostart_path):
            # Look for desktop file
            desktop_file_path = None
            desktop_file_directory = '/usr/share/applications/'
            fullpath = os.path.normpath(os.path.join(desktop_file_directory, autostart_file))
            if os.path.isfile(fullpath):
                desktop_file_path = fullpath
            if desktop_file_path:
                # If we've found the desktop file, create symlink
                if not os.path.exists(autostart_dir):
                    os.mkdir(autostart_dir)
                if os.path.isdir(autostart_dir):
                    log.debug("Installing autostart file.")
                    os.symlink(desktop_file_path, autostart_path)
            #if desktop_file_path
        #if not os.path.isfile(autostart_path)
    #def check_autostart(self)

    def get_version(self):
        return VERSION

    def create_menu(self):
        self.menu = gtk.Menu()
        # Create menu items
        ##Grab screen area
        screen_area_grab = gtk.MenuItem("Select screen area to grab...")
        self.menu.append(screen_area_grab)
        screen_area_grab.connect("activate", self.grab_screen_area)
        screen_area_grab.show()

        ##Open current service site in the browser
        self.open_site_url = open_site_url = gtk.MenuItem("Open " + self.SERVICE_NAME)
        self.menu.append(open_site_url)
        open_site_url.connect("activate", self.open_site)
        open_site_url.show()

        ##Widget for grabbing files
        grab_files = gtk.MenuItem("Show/hide File Grabber")
        grab_files.connect("activate", self.toggle_file_grabber)
        grab_files.show()
        self.menu.append(grab_files)

        ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        ##About
        about_show = gtk.MenuItem("About...")
        about_show.connect("activate", self.about)
        about_show.show()
        self.menu.append(about_show)

        ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        ##Log in
        self.login_menu = gtk.Menu()
        self.imgur_login_menu = gtk.MenuItem("...to Imgur")
        self.imgur_login_menu.connect("activate", self.login, "Imgur")
        self.login_menu.append(self.imgur_login_menu)
        self.droplr_login_menu = gtk.MenuItem("...to Droplr")
        self.droplr_login_menu.connect("activate", self.login, "Droplr")
        self.droplr_login_menu.set_sensitive(False)
        self.login_menu.append(self.droplr_login_menu)
        self.login_menu.show_all()
        if not self.service.is_logged_in():
            self.auth = auth = gtk.MenuItem("Log in...")
            self.auth.set_submenu(self.login_menu)
        else:
            if not self.service.get_username():
                self.service.refresh_access_token() # is done to get username
            string = "Log out (" + self.SERVICE_NAME
            if self.service.get_username():
                string = string + ", " + self.service.get_username()
            string += ")"
            self.auth = auth = gtk.MenuItem(string)
            self.auth_id = auth.connect("activate", self.logout)
        auth.show_all()
        self.menu.append(auth)

        ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        ##Quit
        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)

        if IS_LINUX:
            self.ind.set_menu(self.menu)
    #def create_menu(self)

    def set_default_service(self):
        self.SERVICE_NAME = DEFAULT_SERVICE_NAME
        self.service = globals()[self.SERVICE_NAME](self, self.config, log)
        self.open_site_url.set_label("Open " + self.SERVICE_NAME)

    def login(self, widget, *data):
        self.config.read(CONFIG_FILE)
        self.SERVICE_NAME = data[0]
        self.open_site_url.set_label("Open " + self.SERVICE_NAME)
        self.service = globals()[self.SERVICE_NAME](self, self.config, log)
        self.service.login()
        if self.service.is_logged_in():
            log.debug("Logged in")
            string = "Log out (" + self.SERVICE_NAME
            if self.service.get_username():
                string = string + ", " + self.service.get_username()
            string += ")"
            self.auth.set_label(string)
            self.auth.remove_submenu()
            self.auth_id = self.auth.connect("activate", self.logout)
            self.save_settings()
        else:
            self.set_default_service()
        return False

    def logout(self, widget):
        self.service.logout()
        log.debug("Logged out")
        self.save_settings()
        self.set_default_service()
        self.auth.set_label("Log in...")
        self.auth.disconnect(self.auth_id)
        self.imgur_login_menu.connect("activate", self.login, "Imgur")
        self.auth.set_submenu(self.login_menu)
        self.save_settings()

    def grab_screen_area(self, widget):
        ScreenGrabber(self.select_area_event_handler, log)

    def select_area_event_handler(self, widget, event, selector):
        if event.type == gtk.gdk.MOTION_NOTIFY:
            selector.redraw(event.x, event.y)
        elif event.type == gtk.gdk.BUTTON_PRESS and event.button == 1:
            selector.start_selection(event.x, event.y)
        elif event.type == gtk.gdk.BUTTON_RELEASE and event.button == 1:
            selector.stop_selection(event.x, event.y)
            selector.set_complete_handler(self.take_screen_of_area_complete_handler)
            selector.__del__()
            del selector
        elif (event.type == gtk.gdk.BUTTON_PRESS and event.button == 3) or (
                    event.type == gtk.gdk.KEY_PRESS and event.keyval == gtk.gdk.keyval_from_name('Escape')):
            selector.__del__()
            del selector

    def take_screen_of_area_complete_handler(self, x, y, width, height):
        root = gtk.gdk.get_default_root_window()
        pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, False, 8, width, height)
        pixbuf = pixbuf.get_from_drawable(root, root.get_colormap(), x, y, 0, 0, width, height)
        self.gtk_screen_image = pixbuf
        # Call preview window
        self.preview_screen_of_area()

    def upload_from_pixmap(self):
        (fp, temp_img_file) = tempfile.mkstemp('.png')
        os.close(fp)
        self.gtk_screen_image.save(temp_img_file, "png")
        self.file_grabber.upload_file(temp_img_file, remove=True)

    def preview_screen_of_area(self):
        def response(dialog, resp_id):
            if resp_id == gtk.RESPONSE_UPLOAD:
                self.upload_from_pixmap()

        image = self.gtk_screen_image
        gtk.RESPONSE_UPLOAD = 123
        gtk.stock_add([(gtk.STOCK_GO_UP, "Upload", 0, 0, '')])
        self.preview_dialog = preview_dialog = gtk.Dialog(title="Preview screenshot",
                                                          flags=gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                                                          buttons=(
                                                              gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                                                              gtk.STOCK_GO_UP, gtk.RESPONSE_UPLOAD))
        preview_dialog.set_modal(True)
        preview_dialog.set_decorated(False)
        # Scale image for preview
        preview_image_width = float(image.get_width())
        preview_image_height = float(image.get_height())
        MAX_WIDTH = 600
        MAX_HEIGHT = 400
        if preview_image_width / preview_image_height > MAX_WIDTH / MAX_HEIGHT:
            preview_image_height = int(round((MAX_WIDTH / preview_image_width) * preview_image_height))
            preview_image_width = MAX_WIDTH
        else:
            preview_image_width = int(round((MAX_HEIGHT / preview_image_height) * preview_image_width))
            preview_image_height = MAX_HEIGHT
        preview_image = image.scale_simple(preview_image_width, preview_image_height, gtk.gdk.INTERP_BILINEAR)
        widget_image = gtk.image_new_from_pixbuf(preview_image)
        widget_image.show()
        preview_dialog.vbox.add(widget_image)
        preview_dialog.connect('response', response)
        preview_dialog.run()
        preview_dialog.destroy()

    def show_notification(self, message):
        if IS_LINUX:
            pynotify.init("Fileshare")
            notify = pynotify.Notification("Fileshare", message, self.app_icon)
            notify.show()
        else:
            popup = gtk.Window(gtk.WINDOW_POPUP)
            popup.set_decorated(False)
            popup.set_has_frame(False)
            popup.set_skip_taskbar_hint(True)
            popup.set_skip_pager_hint(True)
            popup.set_can_focus(False)
            popup.set_accept_focus(False)
            popup.set_keep_above(True)
            popup.move(10, 10)
            popup.set_opacity(0.9)
            popup_message = gtk.Label("Fileshare: " + message)
            popup.add(popup_message)
            popup.show_all()
            gobject.timeout_add(5000, popup.destroy)


    ##########################################################################
    def open_site(self, widget):
        webbrowser.open(self.service.get_site_url())

    ##########################################################################
    def toggle_file_grabber(self, widget):
        self.file_grabber.toggle_window()

    ##########################################################################
    def about(self, widget):
        log.debug("Indicator: open About dialog")
        self.about_dialog = gtk.AboutDialog()
        self.about_dialog.set_name("Fileshare Indicator")
        self.about_dialog.set_version(VERSION)

        if IS_LINUX:
            ifile = open("/usr/share/doc/indicator-fileshare/AUTHORS", "r")
        else:
            ifile = open("./AUTHORS", "r")
        self.about_dialog.set_copyright(ifile.read().replace('\x0c', ''))
        ifile.close()

        self.about_dialog.set_website("http://aikikode.github.com/fileshare/")
        self.about_dialog.set_logo(gtk.gdk.pixbuf_new_from_file(self.app_icon))
        self.about_dialog.connect("response", self.about_close)
        self.about_dialog.show()
    #def about(self, widget)

    def about_close(self, widget, event=None):
        log.debug("Indicator: closing About dialog")
        self.about_dialog.destroy()

    ##########################################################################
    # Quit the applet
    def quit(self, widget, data=None):
        self.save_settings()
        log.debug("Indicator: Quitting")
        gtk.main_quit()
#class IndicatorFileshare(threading.Thread)


##############################################################################
def main():
    gtk.main()
    return 0


if __name__ == "__main__":
    # Enable and configure logs
    global log
    cachedir = os.environ.get('XDG_CACHE_HOME', '').strip()
    if not cachedir:
        cachedir = os.path.expanduser("~/.cache")
    try:
        os.mkdir(cachedir)
    except OSError as e:
        if not (e.errno == errno.EEXIST and os.path.isdir(cachedir)):
            sys.exit("Unable to create cache directory")
    log_filename = os.path.join(cachedir, "indicator-fileshare.log")
    log = logging.getLogger('IndicatorFileshare')
    log.propagate = False
    log.setLevel(logging.DEBUG)
    log_handler = logging.handlers.RotatingFileHandler(log_filename, maxBytes=1024 * 1024, backupCount=5)
    log_formatter = logging.Formatter("[%(threadName)s] %(asctime)s - %(levelname)s - %(message)s")
    log_handler.setFormatter(log_formatter)
    log.addHandler(log_handler)

    log.info("------------------------------")
    log.info("Started Fileshare Indicator")
    log.info("Fileshare Indicator version %s" % VERSION)

    # Single instance stuff for fileshare indicator
    myapp = SingleInstance(tempfile.gettempdir() + "/indicator-fileshare-%s.pid" % getpass.getuser())
    # Check is another instance of same program running
    if myapp.is_already_running():
        log.info("Another instance of this program is already running")
        sys.exit("Another instance of this program is already running")

    di = IndicatorFileshare()
    main()
