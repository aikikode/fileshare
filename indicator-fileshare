#!/usr/bin/env python
#
# Copyright 2012
#
# Authors: Denis Kovalev <aikikode@gmail.com>
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of either or both of the following licenses:
#
# 1) the GNU Lesser General Public License version 3, as published by the
# Free Software Foundation; and/or
# 2) the GNU Lesser General Public License version 2.1, as published by
# the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the applicable version of the GNU Lesser General Public
# License for more details.
#
# You should have received a copy of both the GNU Lesser General Public
# License version 3 and version 2.1 along with this program.  If not, see
# <http://www.gnu.org/licenses>
#

import sys, os, shutil, tempfile
import ConfigParser
import gtk
import appindicator
import threading
import webbrowser
import logging, logging.handlers
import commands
# for uploading
import pycurl
import base64
# for parsing server response
import xml.dom.minidom
# for delayed actions
import gobject

VERSION = "0.2"
FILE_GRABBER_SIZE=50
# Anonymous access
ANONYMOUS_API_KEY="fba6adcf28f8439062ea52f22600e672"
# Account based access
CONSUMER_KEY="61aadc0beb93b6181adb6f3833e86fe9050993c85"
CONSUMER_SECRET="fbf2b4ced06d3d399d39dece82d5f488"

CONFIG_FILE="~/.fileshare/settings.cfg"

class SingleInstance(object):
    """ Class to ensure, that single instance of the applet is run for each user """

    # Initialize, specifying a path to store pids
    def __init__(self, pidPath):
        self.pidPath=pidPath
        # See if pidFile exists
        if os.path.exists(pidPath):
            log.debug("SingleInstance: pid file %s exists" % pidPath)
            # Make sure it is not a "stale" pidFile
            pid=open(pidPath, 'r').read().strip()
            # Check list of running pids, if not running it is stale so overwrite
            pidRunning = commands.getoutput('ls -1 /proc | grep ^%s$' % pid)
            log.debug("SingleInstance: pid running %s" % pidRunning)
            self.lasterror = True if pidRunning else False
        else:
            self.lasterror = False

        if not self.lasterror:
            log.debug("SingleInstance: writing new pid %s" % str(os.getpid()))
            # Create a temp file, copy it to pidPath and remove temporary file
            (fp, temp_path)=tempfile.mkstemp()
            try:
                os.fdopen(fp, "w+b").write(str(os.getpid()))
                shutil.copy(temp_path, pidPath)
                os.unlink(temp_path)
            except Exception as e:
                log.error("SingleInstance: exception while renaming '%s' to '%s':\n %s" % (temp_path, pidPath, str(e)))
    #def __init__(self, pidPath)

    def is_already_running(self):
        return self.lasterror

    def __del__(self):
        if not self.lasterror:
            log.debug("SingleInstance: deleting %s" % self.pidPath)
            os.unlink(self.pidPath)
    #def __del__(self)
#class SingleInstance(object)

class IndicatorFileshare(threading.Thread):
    def __init__(self):
        log.debug("Indicator: creating")
        threading.Thread.__init__(self)
        self.read_settings()
        self.ind = appindicator.Indicator("fileshare-services-client",
            "indicator-fileshare",
            appindicator.CATEGORY_APPLICATION_STATUS)
        self.ind.set_status (appindicator.STATUS_ACTIVE)
        self.ind.set_icon("/usr/local/share/indicator-fileshare/media/app_icon.png")
        self.file_grabber = FileGrabber()
        self.create_menu()

    def read_settings(self):
        config = ConfigParser.RawConfigParser()
        try:
            config.read(CONFIG_FILE)
            self.final_token = config.get("Auth", "final_token")
            self.final_token_secret = config.get("Auth", "final_token_secret")
        except:
            self.final_token = None
            self.final_token_secret = None
    #def read_settings(self)

    def create_menu(self):
        self.menu = gtk.Menu()
        # Create menu items
        ## Create screenshot
        buf = "Select screen area to grab..."
        screen_area_grab = gtk.MenuItem(buf)
        self.menu.append(screen_area_grab)
        screen_area_grab.connect("activate", self.grab_screen_area, buf)
        screen_area_grab.show()

        ## Open imgur site
        buf = "Open Imgur"
        open_site_url = gtk.MenuItem(buf)
        self.menu.append(open_site_url)
        open_site_url.connect("activate", self.open_site, buf)
        open_site_url.show()

        ## Widget for grabbing files
        grab_files = gtk.MenuItem("Show/hide File Grabber")
        grab_files.connect("activate", self.toggle_file_grabber)
        grab_files.show()
        self.menu.append(grab_files)

        ## Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        ##About
        about_show = gtk.MenuItem("About...")
        about_show.connect("activate", self.about)
        about_show.show()
        self.menu.append(about_show)

        ##Quit
        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)

        # set menu
        self.ind.set_menu(self.menu)
    #def create_menu(self)

    ##########################################################################
    def grab_screen_area(self, widget, buf):
        screen = gtk.gdk.screen_get_default()
        root = screen.get_root_window()
        gtk.gdk.flush()
        gc = root.new_gc(foreground = gtk.gdk.color_parse('white'),
                function = gtk.gdk.INVERT,
                subwindow_mode = gtk.gdk.INCLUDE_INFERIORS,
                line_width = 1,
                line_style = gtk.gdk.LINE_SOLID,
                cap_style = gtk.gdk.CAP_BUTT,
                join_style = gtk.gdk.JOIN_ROUND)
        if not gtk.gdk.pointer_is_grabbed() and gtk.gdk.pointer_grab(
                root,
                False,
                gtk.gdk.BUTTON_MOTION_MASK |
                    gtk.gdk.BUTTON1_MOTION_MASK |
                    gtk.gdk.POINTER_MOTION_MASK |
                    gtk.gdk.BUTTON_PRESS_MASK |
                    gtk.gdk.BUTTON_RELEASE_MASK,
                None,
                gtk.gdk.Cursor(gtk.gdk.CROSSHAIR)) != gtk.gdk.GRAB_SUCCESS:
            return False
        self.selectAreaMotionX = self.selectAreaMotionY = self.selectAreaMotionWidth = self.selectAreaMotionHeight = 0
        self.selectAreaButtonPressed = False
        gtk.gdk.event_handler_set(self.select_area_event_handler, (root, gc))

    def select_area_event_handler(self, event, data):
        root, gc = data
        if event.type == gtk.gdk.BUTTON_PRESS and event.button == 3:
            log.debug("screenshot cancelled")
            gtk.gdk.pointer_ungrab()
            self.selectAreaButtonPressed = False
        elif event.type == gtk.gdk.MOTION_NOTIFY and self.selectAreaButtonPressed:
            x, y = int(min(self.selectAreaMouseX, event.x_root)), int(min(self.selectAreaMouseY, event.y_root))
            width, height = int(abs(self.selectAreaMouseX - event.x_root)), int(abs(self.selectAreaMouseY - event.y_root))
            root.draw_rectangle(gc, False, self.selectAreaMotionX, self.selectAreaMotionY, self.selectAreaMotionWidth, self.selectAreaMotionHeight)
            root.draw_rectangle(gc, False, x, y, width, height)
            self.selectAreaMotionX, self.selectAreaMotionY, self.selectAreaMotionWidth, self.selectAreaMotionHeight = x, y, width, height
        elif event.type == gtk.gdk.BUTTON_PRESS and event.button == 1:
            self.selectAreaMouseX = event.x_root
            self.selectAreaMouseY = event.y_root
            self.selectAreaButtonPressed = True
        elif event.type == gtk.gdk.BUTTON_RELEASE and event.button == 1:
            gtk.gdk.pointer_ungrab()
            gtk.gdk.event_handler_set(lambda event: gtk.main_do_event(event))
            root.draw_rectangle(gc, False, self.selectAreaMotionX, self.selectAreaMotionY, self.selectAreaMotionWidth, self.selectAreaMotionHeight)
            if self.selectAreaMotionWidth > 0 and self.selectAreaMotionHeight > 0:
                self.take_screen_of_area_complete_handler(self.selectAreaMotionX, self.selectAreaMotionY, self.selectAreaMotionWidth, self.selectAreaMotionHeight)
            self.selectAreaButtonPressed = False
        else:
            gtk.main_do_event(event)

    def take_screen_of_area_complete_handler(self, x, y, width, height):
        root = gtk.gdk.get_default_root_window()
        pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, False, 8, width, height)
        pixbuf = pixbuf.get_from_drawable(root, root.get_colormap(), x, y, 0, 0, width, height)
        self.gtk_screen_image = pixbuf
        # Call preview window
        self.preview_screen_of_area()

    def upload_from_pixmap(self):
        (fp, temp_img_file)=tempfile.mkstemp()
        self.gtk_screen_image.save(temp_img_file, "png")
        self.file_grabber.upload_file(temp_img_file)
        os.remove(temp_img_file)

    def preview_screen_of_area(self):
        def response(dialog, resp_id):
            if resp_id == gtk.RESPONSE_CANCEL:
                dialog.destroy()
            elif resp_id == gtk.RESPONSE_UPLOAD:
                gobject.timeout_add(100, dialog.destroy)
                self.upload_from_pixmap()

        image = self.gtk_screen_image
        gtk.RESPONSE_UPLOAD = 123
        gtk.stock_add([ (gtk.STOCK_GO_UP, "Upload", 0, 0, '') ])
        preview_dialog = gtk.Dialog(title = "Preview screenshot",
                flags = gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                buttons = (
                    gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                    gtk.STOCK_GO_UP, gtk.RESPONSE_UPLOAD))
        preview_dialog.set_modal(True)
        preview_dialog.set_decorated(False)
        # Scale image for preview
        preview_image_width = float(image.get_width())
        preview_image_height = float(image.get_height())
        if preview_image_width / preview_image_height > 3:
            preview_image_height = int(round((400 / preview_image_width) * preview_image_height))
            preview_image_width = 400
        else:
            preview_image_width = int(round((300 / preview_image_height) * preview_image_width))
            preview_image_height = 300
        preview_image = image.scale_simple(preview_image_width, preview_image_height, gtk.gdk.INTERP_BILINEAR)
        widget_image = gtk.image_new_from_pixbuf(preview_image)
        widget_image.show()
        preview_dialog.vbox.add(widget_image)
        preview_dialog.connect('response', response)
        preview_dialog.run()

    ##########################################################################
    def open_site(self, widget, buf):
        webbrowser.open('https://imgur.com/')

    ##########################################################################
    def toggle_file_grabber(self, widget):
        self.file_grabber.toggle_window()

    ##########################################################################
    def about(self, widget):
        log.debug("Indicator: open About dialog")
        self.about_dialog = gtk.AboutDialog()
        self.about_dialog.set_name("Fileshare Indicator")
        self.about_dialog.set_version(VERSION)

        ifile = open("/usr/share/doc/indicator-fileshare/AUTHORS", "r")
        self.about_dialog.set_copyright(ifile.read().replace('\x0c', ''))
        ifile.close()

        self.about_dialog.set_website("https://github.com/aikikode/fileshare")
        logo_path = "/usr/local/share/indicator-fileshare/media/app_icon.png"
        self.about_dialog.set_logo(gtk.gdk.pixbuf_new_from_file(logo_path))
        self.about_dialog.connect("response", self.about_close)
        self.about_dialog.show()
    #def about(self, widget)

    def about_close(self, widget, event=None):
        log.debug("Indicator: closing About dialog")
        self.about_dialog.destroy()

    ##########################################################################
    # Quit the applet
    def quit(self, widget, data=None):
        log.debug("Indicator: Quitting")
        gtk.main_quit()

class FileGrabber():
    """ Applet for drag'n'drop files to. The file is automatically uploaded to
        the hosting and the result URL is copied into the clipboard """
    def __init__(self):
        self.cb = gtk.Clipboard()
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_decorated(False)
        self.window.set_opacity(0.5)
        self.window.set_size_request(FILE_GRABBER_SIZE, FILE_GRABBER_SIZE)
        self.window.set_resizable(False)
        self.window.drag_dest_set(0, [], 0)

        self.window.set_gravity(gtk.gdk.GRAVITY_NORTH_EAST)
        width, height = self.window.get_size()
        self.window.move(gtk.gdk.screen_width() - width - 20, height)

        # Add main widget for grabbing files
        self.image = gtk.Image()
        pixbuf = gtk.gdk.pixbuf_new_from_file("/usr/local/share/indicator-fileshare/media/imgur.png")
        scaled_buf = pixbuf.scale_simple(FILE_GRABBER_SIZE, FILE_GRABBER_SIZE, gtk.gdk.INTERP_BILINEAR)
        self.image.set_from_pixbuf(scaled_buf)
        self.image.show()
        self.window.add(self.image)
        self.window.connect('drag_motion', self.window_drag_motion)
        self.window.connect('drag_drop', self.window_drag_drop)
        self.window.connect('drag_data_received', self.window_drag_data_received)
        self.isShown = False

    def toggle_window(self):
        if self.isShown:
            self.window.hide()
            self.isShown = False
        else:
            self.window.show()
            self.window.set_keep_above(True)    # This may not work: it depends on the window manager
            self.isShown = True

    def window_drag_motion(self, wid, context, x, y, time):
        context.drag_status(gtk.gdk.ACTION_COPY, time)
        return True      # True means "I accept this data"

    def window_drag_drop(self, wid, context, x, y, time):
        wid.drag_get_data(context, context.targets[-1], time)
        return True

    def window_drag_data_received(self, wid, context, x, y, data, info, time):
        file_to_upload = data.get_text().splitlines()[0].replace("file://", "")
        context.finish(True, False, time)
        self.upload_file(file_to_upload)

    def upload_file(self, image):
        log.debug("Uploading file: " + image)
        self.response = ''
        self.base64String = self.img2base64(image)
        self.curl = curl = pycurl.Curl()
        curl.setopt(pycurl.URL, 'http://api.imgur.com/2/upload.xml')
        curl.setopt(pycurl.USERAGENT, 'Mozilla/5.0 Nanoshot')
        curl.setopt(pycurl.POST, 1)
        curl.setopt(pycurl.HTTPPOST, [ ('key', ANONYMOUS_API_KEY), ('image', self.base64String) ])
        curl.setopt(pycurl.WRITEFUNCTION, self.write)
        self.curl.perform()
        log.debug("Response: " + self.response)
        self.dom = xml.dom.minidom.parseString(self.response)
        self.show_result()
        return True

    def img2base64(self, image):
        with open(image, "rb") as image_file:
            encoded_string = base64.b64encode(image_file.read())
        return encoded_string

    def write(self, string):
        self.response += string

    def show_result(self):
        links = []
        for tag in ('original', 'delete_page'):
            link = self.dom.getElementsByTagName(tag)
            if link:
                links.append((tag, link[0].firstChild.nodeValue))
        log.debug(links)
        url = links[0][1]
        self.cb.set_text(url)
        self.cb.store()
        # create a window with result URL
        result_window = gtk.Window()
        result_window.set_decorated(False)
        result_window.set_opacity(0.9)
        result_window.set_resizable(False)
        result_window.set_gravity(gtk.gdk.GRAVITY_NORTH_EAST)
        width, height = result_window.get_size()
        result_window.move(gtk.gdk.screen_width() - width - 20, height)
        l = gtk.Label()
        l.set_text(url + " copied")
        l.show()
        result_window.add(l)
        result_window.show()
        # close the window with URL in 5 seconds
        gobject.timeout_add(5000, result_window.hide)
    #def show_result(self)
#class FileGrabber()


def main():
    gtk.main()
    return 0

if __name__ == "__main__":
    #Enable and configure logs
    global log
    cachedir = os.environ.get('XDG_CACHE_HOME','').strip()
    if not cachedir:
        cachedir = os.path.expanduser("~/.cache")
    log_filename = os.path.join(cachedir, "indicator-fileshare.log")
    log = logging.getLogger('IndicatorFileshare')
    log.propagate = False
    log.setLevel(logging.DEBUG)
    log_handler = logging.handlers.RotatingFileHandler(log_filename, maxBytes=1024*1024, backupCount=5)
    log_formatter = logging.Formatter("[%(threadName)s] %(asctime)s - %(levelname)s - %(message)s")
    log_handler.setFormatter(log_formatter)
    log.addHandler(log_handler)

    log.info("------------------------------")
    log.info("Started Fileshare Indicator")
    log.info("Fileshare Indicator version %s" % VERSION)

    # Single instance stuff for fileshare indicator
    myapp = SingleInstance("/tmp/indicator-fileshare-%d.pid" % os.getuid())
    # check is another instance of same program running
    if myapp.is_already_running():
        log.info("Another instance of this program is already running")
        sys.exit("Another instance of this program is already running")
    # not running, safe to continue...
    gtk.gdk.threads_init()
    gtk.gdk.threads_enter()

    di = IndicatorFileshare()
    main()
    gtk.gdk.threads_leave()
